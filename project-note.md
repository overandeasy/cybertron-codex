Relationship between index, database models, routes, controlers, middlewares:

1. Index has app.use('/api', router) to first receive the API request call from the frontend (client)
2. The request is passed to the router
3. The router parses the request path, method, and payload (in POST method), decides the right endpoint to go to
4. The router endpoint function passes the request to the middleware to verify data, e.g. the login credentials to decide whether to return a reject response or pass on to the right controler function to move forward
5. The controller function deals with the database and return the right response to the frontend through the app.use() Express server function.
   So: server (express().use())--> router--> middleware--> controller-->server

JWT SECRET ENV string can be generated by your OS built-in OpenSSL by running in terminal: openssl rand -base64 64, then use the output string as the secret. You can use use openssl rand -base64 32 which generates a 32 random bytes and base64 encoded string.

Error Handling on server side and client side:
server side response follows this pattern:
export const handleError = <T>(res: Response, payload: ApiResponse<T>) => {
const { status, code, message } = payload;
console.error("Error occurred:", payload);
// Error data included in the payload won't be exposed to http response, but only logged to the server console.
res.status(status).json({
type: "error",
status,
code,
message
});
}

export const handleSuccess = <T>(res: Response, payload: ApiResponse<T>) => {
const { status, code, message, data } = payload;
console.log("Success response:", payload);
res.status(200).json({
type: 'success',
status,
code,
message,
data
});
}

The client-side API call error handling follows this pattern according to the server side error construction:
if (!response.ok) {
const errorData: ApiResponse<null> = await response.json();
console.error("Sign-in failed:", errorData);
const error = new Error(errorData.message || "Sign-in failed"); // The Error constructor makes sure a real Error instance is created, so stack traces, logging tools, and instanceof Error checks behave correctly.
Object.assign(error, errorData); // Assign the errorData properties to the error instance (the previous inclusion of errorData.message in the Error constructor was necessary, not redundant).
throw error;
}
