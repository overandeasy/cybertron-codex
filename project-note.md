Relationship between index, database models, routes, controlers, middlewares on the server:

1. Index has app.use('/api', router) to first receive the API request call from the frontend (client)
2. The request is passed to the router
3. The router parses the request path, method, and payload (when in POST method), decides the right endpoint to go to
4. The router endpoint function passes the request to the middleware to verify data, e.g. the login credentials to decide whether to return a reject response or pass on to the right controler function to move forward
5. The controller function deals with the database and return the right response to the frontend through the app.use() Express server function.
   So: request to server (express().use())--> router--> middleware--> controller-->server response

JWT SECRET ENV string can be generated by your OS built-in OpenSSL by running in terminal: openssl rand -base64 64, then use the output string as the secret. You can use use openssl rand -base64 32 which generates a 32 random bytes and base64 encoded string.

Error Handling on server side and client side:
server side response follows this pattern:
export const handleError = <T>(res: Response, payload: ApiResponse<T>) => {
const { status, code, message } = payload;
console.error("Error occurred:", payload);
// Error data included in the payload won't be exposed to http response, but only logged to the server console.
res.status(status).json({
type: "error",
status,
code,
message
});
}

export const handleSuccess = <T>(res: Response, payload: ApiResponse<T>) => {
const { status, code, message, data } = payload;
console.log("Success response:", payload);
res.status(200).json({
type: 'success',
status,
code,
message,
data
});
}

## Light / Dark mode (system-driven)

Implementation notes:

- Strategy: use Tailwind's `.dark` class strategy (the CSS already defines a `.dark` block with theme variables in `client/app/app.css`).
- Initial paint: to avoid a flash of incorrect colors (FOUC), an inline script is injected into the document `<head>` in `client/app/root.tsx` that runs before React hydrates. It checks `window.matchMedia('(prefers-color-scheme: dark)')` and adds or removes the `.dark` class on `document.documentElement` accordingly.
- Runtime updates: the root `App` component registers a `matchMedia` listener in a `useEffect` that toggles the `.dark` class if the system preference changes while the app is open.

Files touched:

- `client/app/root.tsx` — added the inline initializer script and the `useEffect` listener.
- `client/app/app.css` — unchanged; it already contains the `.dark { ... }` variable overrides.

How to test:

1. Start the client (run `npm run dev` inside `client/`).
2. Open the site in your browser. If your OS is in dark mode, the UI should render with the dark tokens immediately (no flash of light background). If your OS is in light mode, the UI should render in light mode.
3. While the app is open, toggle your OS-level appearance (light/dark). The app should update its theme automatically.

Optional improvements:

- Add a user-controlled theme toggle that stores an explicit preference in `localStorage` and takes precedence over system preference.
- Centralize theme constants into a small shared module if you want a single source for theme-related utilities across client and server code.

The client-side API call error handling follows this pattern according to the server side error construction:
if (!response.ok) {
const errorData: ApiResponse<null> = await response.json();
console.error("Sign-in failed:", errorData);
const error = new Error(errorData.message || "Sign-in failed"); // The Error constructor makes sure a real Error instance is created, so stack traces, logging tools, and instanceof Error checks behave correctly.
Object.assign(error, errorData); // Assign the errorData properties to the error instance (the previous inclusion of errorData.message in the Error constructor was necessary, not redundant).
throw error;
}
